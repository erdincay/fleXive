<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:h="http://java.sun.com/jsf/html"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:c="http://java.sun.com/jstl/core"
      xmlns:fn="http://java.sun.com/jsp/jstl/functions"
      xmlns:t="http://myfaces.apache.org/tomahawk"
      xmlns:adm="http://www.flexive.com/jsf/admin"
      xmlns:fx="http://www.flexive.com/jsf/core">

<ui:composition template="/adm/templates/navigation.xhtml">

    <ui:define name="content">

        <!-- Render tree node styles for types with icons -->
        <style type="text/css">
            <ui:repeat var="type" value="#{fxSystemBean.environment.types}">
                <ui:fragment rendered="#{not type.icon.isEmpty}">
                    .TreeIconType_#{type.id} {
                        background-image: url('<fx:thumbnail pk="#{type.icon.defaultTranslation}" urlOnly="true" previewSize="original" width="16" height="16"/>');
                    }
                </ui:fragment>
            </ui:repeat>
        </style>
		<script type="text/javascript">
            //var contentPage=null;     tracks which page is shown in the content frame..no longer used

            var copyNode=null;
            //copyMode->copy was selected in context menu
            var copyMode=false;
            //cutMode->cut was selected in context menu
            var cutMode=false;
            //flag indicating if the content tree nav frame needs reloading
            //at the moment this is the case when a type has been created or deleted
            var reloadContentTreeNavFrame=false;
            //flag indicating if the tree is shown hierarchically or flat
            var isViewFlat=true;
            var nameEQ = "viewMode=";
                var ca = document.cookie.split(';');
                for(var i=0;i &lt; ca.length;i++) {
                    var c = ca[i];
                    while (c.charAt(0)==' ') c = c.substring(1,c.length);
                    if (c.indexOf(nameEQ) == 0){
                        var value=c.substring(nameEQ.length,c.length);
                        if (value == '0') {
                            isViewFlat = false;

                            break;
                        }
                    }
                }
            var isViewLabels=true;

                //actions defined in StructureTreeControllerBean
            function doTreeAction(action, id, value) {
                if (action =="RENAME_ASSIGNMENT") {
                    setTitle(id,value, false);
                }
                if (action =="RENAME_TYPE") {
                    setTitle(id,value, true);
                }
                if (action =="RENAME_SELECT_TYPE") {
                    setTitle(id,value, true);
                    selectNode(id, true);
                }
                if (action =="RENAME_SELECT_ASSIGNMENT") {
                    setTitle(id,value, false);
                    selectNode(id, false);
                }
                if (action=="RELOAD_SELECT_TYPE") {
                    reloadAndKeepExpanded();
                    openNode(id, true);
                }
                if (action=="RELOAD_SELECT_ASSIGNMENT") {
                    reloadAndKeepExpanded();
                    selectNode(id, false);
                }
                if (action=="RELOAD_OPEN_ASSIGNMENT") {
                    reloadAndKeepExpanded();
                    openNode(id, false);
                }
                if (action=="RELOAD_EXPAND_TYPE") {
                    reloadAndKeepExpanded();
                }
                if (action=="RELOAD_EXPAND_ASSIGNMENT") {
                    reloadAndKeepExpanded();
                    expandToNodeWithId(id, false);
                }
            }

            /* expands the tree and selects the node with ID id
                returns the node object
                isType controls if the node is an assignment or type
                true for type, false for assignment
             */
             function selectNode(id, isType) {
                var node = expandToNodeWithId(id, isType);
                getFxSelector().deselectAll();
                getFxSelector().select(node);
                //scroll node into view
                node.domNode.scrollIntoView();
                return node;
            }

            /* expands the tree, selects node and performs click operation
             */
            function openNode(id, isType) {
                var node = selectNode(id,isType);
                structureTreeClickHandler(node, true);
            }

            /*
                isType controls if the node is an assignment or type
                true for type, false for assignment
            */
            function setTitle(id, title, isType) {
                var node= expandToNodeWithId(id, isType);
                if (node.title != title)
                    node.setTitle(title);
            }

            function reloadStructureTree() {
                var newChildren = eval("(" + flexive.util.getJsonRpc().StructureTreeWriter.renderStructureTree(-1, isViewFlat, isViewLabels) + ")");
                dojo.widget.byId('structureTree').setChildren(newChildren);
                //contentPage=null;
            }

            function getFxSelector() {
                return dojo.widget.byId('structureTree').fxSelector;
            }

            function getFxController() {
                return dojo.widget.byId('structureTree').fxController;
            }

            /*expands all parents up to the node with ID id
            the node objects are lazily initialized, altough they are searchable via the propertyId,
            the actual node object is initialized when the parent node is expanded, so it is necessarry to
            obtain the possibly uninitialized children anew after the parent was expanded
            isType controls if the node is an assignment or type
            true for type, false for assignment
            return the initialized node object with the ID id
            */
            function expandToNodeWithId(id, isType) {
                var nodePath =getNodePath(id, isType);
                if (nodePath == null)
                    return null;
                var childNodeToExpand=dojo.widget.byId('structureTree');
                for (var i=0;i&lt;nodePath.length-1;i++) {
                    var childIndex=nodePath[i][1];
                    childNodeToExpand=childNodeToExpand.children[childIndex];
                    getFxController().expandToNode(childNodeToExpand,true);
                }
                return childNodeToExpand.children[nodePath[nodePath.length-1][1]];
             }

            function arraycopy(source) {
                dest = new Array(source.length);
                for (var i=0;i&lt;source.length;i++) {
                    dest[i]=source[i];
                }
                return dest;
            }

           /*Returns a 2dim array of nodes which are currently expanded, first array entry is id,
            *second is node doc type.
            *
            */
            function getExpandedNodes() {
                return _buildExpandedArray(dojo.widget.byId('structureTree').children, new Array());
            }

            function _buildExpandedArray(childArray, expandedArray) {
                var harray=arraycopy(expandedArray);
                for (var i=0;i&lt;childArray.length;i++) {
                    var node = childArray[i];
                    if (node.isExpanded) {
                       harray.push(new Array(getNodeId(node), node.nodeType));
                       harray = _buildExpandedArray(node.children, harray);
                    }
                }
                return harray;
            }

            /* saves expanded state of the tree, reloads the tree and
             * restores the expanded state.
             */
            function reloadAndKeepExpanded() {
                var ea = getExpandedNodes();
                reloadStructureTree();
                try {
                    // if we show hierarchical view and there are no expanded nodes expand the root node
                    if (ea.length == 0 &amp;&amp; !isViewFlat) {
                       expandToNodeWithId(0, true).expand();
                    }
                } catch (e) {
                    alert (e);
                }
                for (var i=0;i&lt;ea.length;i++) {
                    var node = expandToNodeWithId(ea[i][0], isType(ea[i][1]));
                    if (node != null)
                        node.expand();
                }
            }

            /*returns the nodepath as an 2-dim array of nodes and indices, starting from root's
             children upto the node with id ID. The node objects are stored in a 2-dim array,
             where [0] represents the actual node and [1] represents it's index in the parent nodes
             isType controls if the node is an assignment or type
             true for type, false for assignment
             */
            function getNodePath(id, isType) {
                var children = dojo.widget.byId('structureTree').children;
                return searchNode(children,new Array() ,id, isType);
            }

            /*
             * recursively searches for a node with the given id
             * isType controls if the node is an assignment or type
             * true for type, false for assignment
             */
            function searchNode(searcharray, historyarray, id, isType) {
                var foundnode =null;
                for (var i=0;i&lt;searcharray.length &amp;&amp; foundnode==null;i++) {
                    var node = searcharray[i];
                    if (node.children) {
                        if (node.children.length >0) {
                           harray = arraycopy(historyarray);
                           harray.push(new Array(node,i));
                           foundnode=searchNode(node.children, harray, id, isType);
                        }
                    }
                    if(isType &amp;&amp; node["typeId"]== id || !isType &amp;&amp; node["assignmentId"]==id) {
                        foundnode=node;
                        historyarray.push(new Array(node,i));
                        return historyarray;
                    }
                }
                return foundnode;
            }

            function structureTreeClickHandler(node, doubleClick) {
                doContentAction(node, "openInstance", doubleClick);
            }

            //should be invoked by the click handler when normally clicking on tree nodes
            function doContentAction(node, defaultAction, doubleClick) {
                var nodeId = getNodeId(node);
                var nodeType = node.nodeType;
                if (!doubleClick &amp;&amp; nodeId != null &amp;&amp; nodeId != -1 &amp;&amp; parent.frames["contentFrame"].addQueryNode) {
                    // add to search query
                    if (isAssignment(nodeType)) {
                        // check if assignment is searchable and add to query
                        if (flexive.util.getJsonRpc().StructureTreeEditor.isAssignmentSearchable(nodeId))
                            parent.frames["contentFrame"].addQueryNode(nodeId, nodeType);
                        else
                            alertDialog("#{fxMessageBean['StructureTree.message.property.notSearchable']}");
                    }
                    else
                        // types are unchecked
                        parent.frames["contentFrame"].addQueryNode(nodeId, nodeType);
                }
                else if (defaultAction == "openInstance") {
                    if (doubleClick)
                        doContentActionFromContextMenu(node, defaultAction);
                }
                else doContentActionFromContextMenu(node, defaultAction);
            }

            //should be invoked from the nodes in the context menu
            function doContentActionFromContextMenu(node, defaultAction) {
                if ("Assignment" == node.nodeType || "AssignmentSystemInternal" == node.nodeType) {
                    invokeContentAction("adm/structure/propertyAssignmentEditor.jsf", defaultAction, {id: node["assignmentId"]});
                }
                else if (isType(node.nodeType)) {
                    invokeContentAction("adm/structure/typeEditor.jsf", defaultAction, {id: node["typeId"]});
                }
                else if ("Group" == node.nodeType) {
                    invokeContentAction("adm/structure/groupAssignmentEditor.jsf", defaultAction, {id: node["assignmentId"]});
                }
            }

            function showNode(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                doContentActionFromContextMenu(menu.getTreeNode(), "openInstance");
            }

            function editNode(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                doContentActionFromContextMenu(menu.getTreeNode(), "editInstance");
            }

            // create a new property as child of the current node
            function createProperty(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var parentId = getNodeId(menu.getTreeNode());

                invokeContentAction("adm/structure/propertyEditor.jsf", "createProperty", {id: parentId, nodeType: menu.getTreeNode().nodeType});
                //contentPage=null;
            }

            // create a derived type of the current node
            function createDerivedType(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var parentId = getNodeId(menu.getTreeNode());

                promptName(function(alias) {
                    if (alias!=null &amp;&amp; alias!="") {
                        try {
                            newTypeId =flexive.util.getJsonRpc().StructureTreeEditor.createDerivedType(parentId, alias);
                            reloadAndKeepExpanded();
                            selectNode(newTypeId, true);
                        }
                        catch (e) {
                            alertDialog(e.message);
                        }
                    }
                });
            }

             // create a new group as child of the current node
            function createGroup(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var parentId = getNodeId(menu.getTreeNode());

                invokeContentAction("adm/structure/groupEditor.jsf", "createGroup", {id: parentId, nodeType: menu.getTreeNode().nodeType});
                //contentPage=null;
            }

            // create a new type
            function createType(menuItem) {
                invokeContentAction("adm/structure/typeEditor.jsf", "createType", {});
                //contentPage=null;
            }

            function createTypeRelation(menuItem) {
                invokeContentAction("adm/structure/typeEditor.jsf", "createTypeRelation", {});
                //contentPage=null;
            }

            //checks if the structure element opened in the contet frame
            //is still valid (== does still exist).
            function isContentFrameValidAfterDeletion() {
                if (getContentFrame().location.href.indexOf("/flexive/adm/structure/") >0) {
                    var assId=-1; var typeId=-1;
                    if (getContentFrame().document.getElementById("frm:struct_internal_assignmentId") != null)
                        assId = getContentFrame().document.getElementById("frm:struct_internal_assignmentId").value;
                    if (getContentFrame().document.getElementById("frm:struct_internal_typeId") != null)
                        typeId = getContentFrame().document.getElementById("frm:struct_internal_typeId").value;
                    if (assId != -1 &amp;&amp; !flexive.util.getJsonRpc().StructureTreeEditor.isAssignmentExists(assId))
                        return false;
                    if (typeId != -1 &amp;&amp; !flexive.util.getJsonRpc().StructureTreeEditor.isTypeExists(typeId))
                        return false;
                }
                return true;
            }

            function deleteAssignment(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var id = menu.getTreeNode().assignmentId;
                var label = menu.getTreeNode().title;
                var nodeType = menu.getTreeNode().nodeType;
                _deleteAssignment(id, label, nodeType);
            }

            function _deleteAssignment(id, label, nodeType) {
                var messageAssignment = "#{fxMessageBean['StructureTree.message.delete.assignment']}";
                var messageGroup= "#{fxMessageBean['StructureTree.message.delete.group']}";
                confirmDialog(nodeType == "Group" ? messageGroup.replace("{0}", label) : messageAssignment.replace("{0}", label), function() {
                    try {
                        flexive.util.getJsonRpc().StructureTreeEditor.deleteAssignment(id);
                        if (copyNode!=null &amp;&amp; copyNode.assignmentId ==id &amp;&amp; (copyNode.nodeType=="Group" || copyNode.nodeType=="Assignment"))
                            copyNode=null;
                        reloadAndKeepExpanded();
                        if (!isContentFrameValidAfterDeletion()) {
                            loadContentPage("adm/structure/content.jsf");
                            parent.gotoNavMenu(1);
                        }
                    }
                    catch (e) {
                        alertDialog(e.message);
                        reloadAndKeepExpanded();
                        if (!isContentFrameValidAfterDeletion()) {
                            loadContentPage("adm/structure/content.jsf");
                        }
                    }
                });
            }

            function deleteType(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var id = menu.getTreeNode().typeId;
                var label = menu.getTreeNode().title;
                _deleteType(id, label);
            }

            function _deleteType(id, label) {
                var message = "#{fxMessageBean['StructureTree.message.delete.type']}";
                confirmDialog(message.replace("{0}", label), function() {
                    try {
                        flexive.util.getJsonRpc().StructureTreeEditor.deleteType(id);
                        reloadAndKeepExpanded();
                        reloadContentTreeNavFrame=true;
                        if (!isContentFrameValidAfterDeletion()) {
                            loadContentPage("adm/structure/content.jsf");
                        }
                    }
                    catch (e) {
                        alertDialog(e.message);
                        reloadAndKeepExpanded();
                        if (!isContentFrameValidAfterDeletion()) {
                            loadContentPage("adm/structure/content.jsf");
                        }
                    }
                });
            }

            function copyAssignment(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                copyNode = menu.getTreeNode();
                copyMode=true;
                cutMode=false;
            }

            function cutAssignment(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                copyNode = menu.getTreeNode();
                copyMode=false;
                cutMode=true;
            }

            function promptAlias(onSuccess) {
                promptDialog("#{fxMessageBean['StructureTree.message.enterAlias']}", "", function(alias) {
                    var valid = flexive.util.getJsonRpc().StructureTreeEditor.validateAlias(alias);
                    if (!valid) {
                        alertDialog("#{fxMessageBean['StructureTree.message.err.invalidAlias']}");
                    } else {
                        onSuccess(alias);
                    }
                });
            }

            function promptName(onSuccess) {
                promptDialog("#{fxMessageBean['StructureTree.message.enterName.derivedType']}", "", function(alias) {
                    var valid = flexive.util.getJsonRpc().StructureTreeEditor.validateAlias(alias);
                    if (!valid) {
                        alertDialog("#{fxMessageBean['StructureTree.message.err.invalidName']}");
                    } else {
                        onSuccess(alias);
                    }
                });
            }

            function pasteBelow(menuItem, alias) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var destId = getNodeId(menu.getTreeNode());
                var destNodeType=menu.getTreeNode().nodeType;
                try {
                    var isNewAlias = alias != null &amp;&amp; alias !="";
                    //check if nodes are at same level
                    var sameLevel = flexive.util.getJsonRpc().StructureTreeEditor.isSameLevel(copyNode.assignmentId, destId);
                    var newAssignmentId = -1;
                    if (copyMode || !sameLevel || (sameLevel &amp;&amp; isNewAlias)) {
                        //in copy mode or for different levels or for a new alias create a derived assignment
                        newAssignmentId = flexive.util.getJsonRpc().StructureTreeEditor.pasteAssignmentRelative(getNodeId(copyNode), copyNode.nodeType , destId, destNodeType ,alias, 1);
                        if (cutMode) {
                            flexive.util.getJsonRpc().StructureTreeEditor.deleteAssignment(copyNode.assignmentId);
                            copyNode=null;
                        }
                        reloadAndKeepExpanded();
                        expandToNodeWithId(newAssignmentId, false);
                    } else {
                        // otherwise == (cut mode and same level and no alias) just perform move operation
                        flexive.util.getJsonRpc().StructureTreeEditor.moveAssignmentRelative(getNodeId(copyNode), copyNode.nodeType, destId, 1);
                        reloadAndKeepExpanded();
                        expandToNodeWithId(getNodeId(copyNode), false);
                    }
                }
                catch (e) {
                    alertDialog(e.message);
                }
            }

            function pasteBelowAs(menuItem) {
                promptAlias(function(alias) {
                    if (alias!=null &amp;&amp; alias!="") {
                        pasteBelow(null, alias);
                    }
                });
            }

            function pasteAbove(menuItem, alias) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var destId = getNodeId(menu.getTreeNode());
                var destNodeType=menu.getTreeNode().nodeType;
                try {
                    var isNewAlias = alias != null &amp;&amp; alias !="";
                    //check if nodes are at same level
                    var sameLevel = flexive.util.getJsonRpc().StructureTreeEditor.isSameLevel(copyNode.assignmentId, destId);
                    var newAssignmentId = -1;
                    if (copyMode || !sameLevel || (sameLevel &amp;&amp; isNewAlias)) {
                        //in copy mode or for different levels or for a new alias create a derived assignment
                        newAssignmentId = flexive.util.getJsonRpc().StructureTreeEditor.pasteAssignmentRelative(getNodeId(copyNode), copyNode.nodeType , destId, destNodeType ,alias, 0);
                        if (cutMode) {
                            flexive.util.getJsonRpc().StructureTreeEditor.deleteAssignment(copyNode.assignmentId);
                            copyNode=null;
                        }
                        reloadAndKeepExpanded();
                        expandToNodeWithId(newAssignmentId, false);
                    } else {
                        // otherwise == (cut mode and same level and no alias) just perform move operation
                        flexive.util.getJsonRpc().StructureTreeEditor.moveAssignmentRelative(getNodeId(copyNode), copyNode.nodeType, destId, 0);
                        reloadAndKeepExpanded();
                        expandToNodeWithId(getNodeId(copyNode), false);
                    }
                }
                catch (e) {
                    alertDialog(e.message);
                }
            }

            function pasteAboveAs(menuItem) {
                promptAlias(function(alias) {
                    if (alias!=null &amp;&amp; alias!="") {
                        pasteAbove(null,alias);
                    }
                });
            }

            function pasteInto(menuItem, alias) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var parentId = getNodeId(menu.getTreeNode());
                var parentType= menu.getTreeNode().nodeType;
                try {
                    var newAssignmentId = flexive.util.getJsonRpc().StructureTreeEditor.pasteAssignmentInto(getNodeId(copyNode), copyNode.nodeType , parentId, parentType, alias);
                    reloadAndKeepExpanded();
                    expandToNodeWithId(newAssignmentId, false);
                    if (cutMode) {
                        //cut out == delete copyNode
                        flexive.util.getJsonRpc().StructureTreeEditor.deleteAssignment(copyNode.assignmentId);
                        copyNode=null;
                        reloadAndKeepExpanded();
                        expandToNodeWithId(newAssignmentId, false);
                    }
                }
                catch (e) {
                        alertDialog(e.message);
                }
            }

            function pasteIntoAs(menuItem) {
                promptAlias(function(alias) {
                    if (alias!=null &amp;&amp; alias!="") {
                        pasteInto(null, alias);
                    }
                });
            }

            function createContent(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var parentId = menu.getTreeNode().typeId;

                invokeContentAction("adm/content/contentEditor.jsf", "newInstance", {typeId: parentId});
                //contentPage=null;
            }

            function getNodeId(node) {
                return node.assignmentId != null
                        ? node.assignmentId
                        : node.typeId;
            }

            function searchContents(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var nodeId = getNodeId(menu.getTreeNode());
                var nodeType = menu.getTreeNode().nodeType;

                if (isAssignment(nodeType) &amp;&amp; !flexive.util.getJsonRpc().StructureTreeEditor.isAssignmentSearchable(nodeId)) {
                    alertDialog("#{fxMessageBean['StructureTree.message.property.notSearchable']}");
                    return;
                }
                if (parent.frames["contentFrame"].isQueryEditor) {
                    // add node to query
                    parent.frames["contentFrame"].addQueryNode(nodeId, nodeType);
                } else {
                    // open query editor
                    if (isType(nodeType)) {
                        invokeContentAction("adm/search/query.jsf", "typeSearch", {typeId: nodeId});
                    } else {
                        invokeContentAction("adm/search/query.jsf", "assignmentSearch", {assignmentId: nodeId});
                    }
                }
                // submit query
                //invokeContentAction("adm/search/searchResult.jsf", "nodeSearch", {nodeId: nodeId});

                //contentPage=null;
            }

            function searchContentsImmediate(menuItem) {
                // show type query results
                var menu = dojo.widget.byId("structureTreeMenu");
                invokeContentAction("adm/search/searchResult.jsf", "typeSearch", {typeId: getNodeId(menu.getTreeNode())});
            }

            function searchContentsByProperty(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var assignmentId = getNodeId(menu.getTreeNode());
                var propertyId = menu.getTreeNode().propertyId;
                if (!flexive.util.getJsonRpc().StructureTreeEditor.isAssignmentSearchable(assignmentId)) {
                    alertDialog("#{fxMessageBean['StructureTree.message.property.notSearchable']}");
                    return;
                };
                if (parent.frames["contentFrame"].isQueryEditor) {
                    parent.frames["contentFrame"].addPropertyQueryNode(propertyId);
                } else {
                    invokeContentAction("adm/search/query.jsf", "propertySearch", {propertyId: propertyId});
                }
            }

            function createTestData(menuItem) {
                var menu = dojo.widget.byId("structureTreeMenu");
                var nodeId = getNodeId(menu.getTreeNode());
                if (isType(menu.getTreeNode().nodeType))
                    invokeContentAction("adm/content/createTestData.jsf", "setTypeId", {typeId: nodeId});
            }

            function importType(menuItem) {
                invokeContentAction("adm/main/importexport/structureImport.jsf", "source", "type");
            }

            function exportTypeMenu(menuItem) {
                try {
                    invokeContentAction("adm/main/importexport/structureExport.jsf");
                } catch(ex) {
                    alertDialog(ex);
                }
            }

            function exportType(menuItem) {
                try {
                    var menu = dojo.widget.byId("structureTreeMenu");
                    var nodeId = getNodeId(menu.getTreeNode());
                    invokeContentAction("adm/main/importexport/structureExportResult.jsf", "exportType", {typeId: nodeId});
                } catch(ex) {
                    alertDialog(ex);
                }
            }

            function exportTypeNoDeps(menuItem) {
                try {
                    var menu = dojo.widget.byId("structureTreeMenu");
                    var nodeId = getNodeId(menu.getTreeNode());
                    invokeContentAction("adm/main/importexport/structureExportResult.jsf", "exportTypeNoDeps", {typeId: nodeId});
                } catch(ex) {
                    alertDialog(ex);
                }
            }

            //checks if the assignment that is currently being deleted is opened for editing
            //in the content frame
            function checkIfDeletingActiveContent() {
                if (getContentFrame().location.href.contains("/flexive/adm/structure/")) {

                }
            }

            function showTreeMenu() {
                var menu = dojo.widget.byId("structureTreeMenu");
                if (menu.getTreeNode() == null) {
                    return;
                }
                var node = menu.getTreeNode();
                if (!node.nodeType)
                    return;
                var lackRole = #{not fxSystemBean.isInRole['StructureManagement']};
                var notGlobalSupervisor = #{not fxSystemBean.isInRole['GlobalSupervisor']};
                var mayOpen = !lackRole || #{fxSystemBean.isInRole['ScriptManagement']};
                var pasteGroupIntoSelf = copyNode != null &amp;&amp; (node.nodeType=="Assignment" || node.nodeType =="Group") &amp;&amp; copyNode.nodeType =="Group" &amp;&amp; flexive.util.getJsonRpc().StructureTreeEditor.isParentAssignment(getNodeId(copyNode), getNodeId(node));
                var isSameLevel = copyNode != null &amp;&amp; (node.nodeType=="Assignment" || node.nodeType =="Group") &amp;&amp; flexive.util.getJsonRpc().StructureTreeEditor.isSameLevel(copyNode.assignmentId, node.assignmentId);
                setActionDisabled(menu.getTreeNode(), "editNode", !mayOpen || (node.nodeType =="AssignmentSystemInternal" &amp;&amp; notGlobalSupervisor));
                setActionDisabled(menu.getTreeNode(), "createContent", !isType(node.nodeType));
                setActionDisabled(menu.getTreeNode(), "createProperty", !(node.nodeType=="Group" || isType(node.nodeType)) || lackRole);
                setActionDisabled(menu.getTreeNode(), "createGroup", !(node.nodeType=="Group" || isType(node.nodeType)) || lackRole);
                setActionDisabled(menu.getTreeNode(), "createDerivedType", !(node.nodeType=="Type" || lackRole));
                setActionDisabled(menu.getTreeNode(), "deleteAssignment", node.nodeType!="Assignment" || lackRole || (node.nodeType =="AssignmentSystemInternal" &amp;&amp; notGlobalSupervisor));
                setActionDisabled(menu.getTreeNode(), "deleteGroup", node.nodeType!="Group" || lackRole);
                setActionDisabled(menu.getTreeNode(), "deleteType", !isType(node.nodeType) || lackRole);
                setActionDisabled(menu.getTreeNode(), "copyAssignment", lackRole || node.nodeType!="Group" &amp;&amp; node.nodeType!="Assignment");
                setActionDisabled(menu.getTreeNode(), "searchContents", !isType(node.nodeType) &amp;&amp; !isAssignment(node.nodeType));
                setActionDisabled(menu.getTreeNode(), "searchContentsImmediate", !isType(node.nodeType));
                setActionDisabled(menu.getTreeNode(), "searchPropertyContents", !isAssignment(node.nodeType));
                setActionDisabled(menu.getTreeNode(), "cutAssignment", lackRole || node.nodeType!="Assignment" &amp;&amp; node.nodeType!="Group");

                //paste a copied or cut assignment node below a selected node
                //cut: only allowed if not pasting below itsself and if not pasting a group into itsself or one of its children
                //copy: only allowed if not at the same level with selected node -> use pasteAboveAs
                setActionDisabled(menu.getTreeNode(), "pasteBelow", lackRole || copyNode==null || (node.nodeType!="Assignment" &amp;&amp; node.nodeType!="Group") ||
                                (copyMode &amp;&amp; isSameLevel) || (cutMode &amp;&amp; getNodeId(copyNode) == getNodeId(node)) || (cutMode &amp;&amp; pasteGroupIntoSelf));

                //paste a copied or cut assignment node above a selected node
                //cut: only allowed if not pasting above ittself and if not pasting a group into itsself or one of its children
                //copy: only allowed if not at the same level with selected node -> use pasteAboveAs
                setActionDisabled(menu.getTreeNode(), "pasteAbove", lackRole || copyNode==null || (node.nodeType!="Assignment" &amp;&amp; node.nodeType!="Group") ||
                                (copyMode &amp;&amp; isSameLevel) || (cutMode &amp;&amp; getNodeId(copyNode) == getNodeId(node)) || (cutMode &amp;&amp; pasteGroupIntoSelf));
                //paste a copied or cut assignment node into a selected type or group
                //copy: only allowed if not pasting directly into the own parent -> use paste into as
                //cut: only allowed if not pasting a group into itsself or one of its children
                setActionDisabled(menu.getTreeNode(), "pasteInto", lackRole || copyNode==null || (!isType(node.nodeType) &amp;&amp; node.nodeType!="Group") ||
                            flexive.util.getJsonRpc().StructureTreeEditor.isDirectChild(copyNode.assignmentId, getNodeId(node), node.nodeType) 
                            || (cutMode &amp;&amp; getNodeId(copyNode) == getNodeId(node)) || (cutMode &amp;&amp; pasteGroupIntoSelf));

                //paste a copied or cut assignment below another assignment prompting for a different alias
                //cut: only allowed if not pasting a group into itsself or one of its children
                setActionDisabled(menu.getTreeNode(), "pasteBelowAs", lackRole || copyNode==null ||(node.nodeType!="Assignment" &amp;&amp; node.nodeType!="Group") ||
                            (cutMode &amp;&amp; pasteGroupIntoSelf));

                //paste a copied or cut assignment above another assignment prompting for a different alias
                //cut: only allowed if not pasting a group into itsself or one of its children
                setActionDisabled(menu.getTreeNode(), "pasteAboveAs", lackRole || copyNode==null ||
                            (node.nodeType!="Assignment" &amp;&amp; node.nodeType!="Group") || (cutMode &amp;&amp; pasteGroupIntoSelf));

                //paste a copied or cut assignment into a group assignment or type prompting for a different alias
                //cut: only allowed if not pasting a group into itsself or one of its children
                setActionDisabled(menu.getTreeNode(), "pasteIntoAs", lackRole || copyNode==null ||
                            (!isType(node.nodeType) &amp;&amp; node.nodeType!="Group") || (cutMode &amp;&amp; getNodeId(copyNode) == getNodeId(node)) || (cutMode &amp;&amp; pasteGroupIntoSelf));

                //cut: only allowed if not pasting a group into itsself or one of its children
                setActionDisabled(menu.getTreeNode(), "pasteSubMenu", lackRole || copyNode==null || (cutMode &amp;&amp; pasteGroupIntoSelf));

                setActionDisabled(menu.getTreeNode(), "createTestData", lackRole || !isType(node.nodeType));
                setActionDisabled(menu.getTreeNode(), "exportType", lackRole || !isType(node.nodeType));
                setActionDisabled(menu.getTreeNode(), "exportTypeNoDeps", lackRole || !isType(node.nodeType));
                menu.show_();
            }

            function isType(nodeType) {
                return nodeType.indexOf("Type") == 0;
            }

            function isAssignment(nodeType) {
                return nodeType == "Assignment" || nodeType == "AssignmentSystemInternal";
            }

            function enableSearchMode() {
                setBackgroundImage("adm/images/tree/background_search.png");
            }

            function disableSearchMode() {
                removeBackgroundImage();
            }

            function toggleHierarchyView() {
                isViewFlat = !isViewFlat;
                var date = new Date();
                date.setTime(date.getTime()+(60*24*60*60*1000));    // remember for 60 days
                document.cookie = 'viewMode=' + (isViewFlat ? '1':'0') + '; expires=' +date.toGMTString() + '; path=/';
                setImage("mainNavForm:imgTreeHierarchy", "adm/images/layout/tree_view_" + (isViewFlat ? "flat" : "hierarchical") + ".png");
                reloadAndKeepExpanded();
            }

            function toggleAliasView() {
                isViewLabels = !isViewLabels;
                setImage("mainNavForm:imgTreeLabelView", "adm/images/layout/tree_label_" + (isViewLabels ? "label" : "alias") + ".png");
                reloadAndKeepExpanded();
            }

            dojo.addOnLoad(function() {
                if (getContentFrame().isQueryEditor) {
                    enableSearchMode();
                }
                // so if we need hierarchical view, just add another onLoad function to change it
                if (!isViewFlat){
                    dojo.addOnLoad(function() {
                        // so that the toggle work right we must set the flag to ture
                        isViewFlat = true;
                        toggleHierarchyView();
                    });
                }
            });
		</script>
        <div style="display:none;"><iframe id="exportFrame" ><!--empty--></iframe></div>
        <adm:tree name="structureTree" targetId="structureTreeContainer"  extensionPoint="/tree/adm/structure"
                  clickHandler="structureTreeClickHandler" docIcons="true" expandFirstNode="false">

            <adm:treeContextMenu showHandler="showTreeMenu">
                <adm:treeContextMenuItem icon="open" treeActions="showNode" labelKey="StructureTree.menu.open" clickHandler="showNode"/>
                <adm:treeContextMenuItem icon="edit" treeActions="editNode" labelKey="StructureTree.menu.edit" clickHandler="editNode"/>
                <adm:treeContextMenuItem icon="export" treeActions="exportType" labelKey="StructureTree.menu.exportType" clickHandler="exportType"/>
                <adm:treeContextMenuItem icon="export" treeActions="exportTypeNoDeps" labelKey="StructureTree.menu.exportTypeNoDeps" clickHandler="exportTypeNoDeps"/>
                <adm:treeContextMenuItem icon="property" treeActions="createProperty" labelKey="StructureTree.menu.createProperty" clickHandler="createProperty"/>
                <adm:treeContextMenuItem icon="group" treeActions="createGroup" labelKey="StructureTree.menu.createGroup" clickHandler="createGroup" />
                <adm:treeContextMenuItem icon="fxType" treeActions="createDerivedType" labelKey="StructureTree.menu.createDerivedType" clickHandler="createDerivedType" />
                <adm:treeContextMenuItem icon="query" treeActions="searchContents" labelKey="StructureTree.menu.searchContents" clickHandler="searchContents"/>
                <adm:treeContextMenuItem icon="searchresults" treeActions="searchContentsImmediate" labelKey="StructureTree.menu.searchContentsImmediate" clickHandler="searchContentsImmediate"/>
                <adm:treeContextMenuItem icon="query" treeActions="searchPropertyContents" labelKey="StructureTree.menu.searchContents.property" clickHandler="searchContentsByProperty"/>
                <fx:dojoMenuSeparator/>
                <adm:treeContextMenuItem icon="new" treeActions="createContent" labelKey="ContentTree.menu.create" clickHandler="createContent"/>
                <adm:treeContextMenuItem icon="createTestData" treeActions="createTestData" labelKey="StructureTree.menu.createTestData" clickHandler="createTestData" />
                <fx:dojoMenuSeparator/>
                <adm:treeContextMenuItem treeActions="copyAssignment" icon="copy" labelKey="StructureTree.menu.copyAssignment" clickHandler="copyAssignment"/>
                <adm:treeContextMenuItem treeActions="pasteInto" icon="paste" labelKey="StructureTree.menu.paste.into" clickHandler="pasteInto"/>
                <adm:treeContextMenuItem treeActions="pasteSubMenu" icon="paste" labelKey="StructureTree.menu.paste.submenu">
                    <adm:treeContextMenuItem treeActions="pasteAbove" icon="paste" labelKey="StructureTree.menu.paste.above" clickHandler="pasteAbove"/>
                    <adm:treeContextMenuItem treeActions="pasteBelow" icon="paste" labelKey="StructureTree.menu.paste.below" clickHandler="pasteBelow"/>
                    <fx:dojoMenuSeparator/>
                    <adm:treeContextMenuItem treeActions="pasteAboveAs" icon="paste" labelKey="StructureTree.menu.paste.aboveAs" clickHandler="pasteAboveAs"/>
                    <adm:treeContextMenuItem treeActions="pasteBelowAs" icon="paste" labelKey="StructureTree.menu.paste.belowAs" clickHandler="pasteBelowAs"/>
                    <adm:treeContextMenuItem treeActions="pasteIntoAs" icon="paste" labelKey="StructureTree.menu.paste.intoAs" clickHandler="pasteIntoAs"/>
                </adm:treeContextMenuItem>
                <adm:treeContextMenuItem icon="cut" treeActions="cutAssignment" labelKey="StructureTree.menu.cut.assignment" clickHandler="cutAssignment"/>
                <adm:treeContextMenuItem icon="delete" treeActions="deleteAssignment" labelKey="StructureTree.menu.delete.assignment" clickHandler="deleteAssignment"/>
                <adm:treeContextMenuItem icon="delete" treeActions="deleteGroup" labelKey="StructureTree.menu.delete.group" clickHandler="deleteAssignment"/>
                <adm:treeContextMenuItem icon="delete" treeActions="deleteType" labelKey="StructureTree.menu.delete.type" clickHandler="deleteType"/>
            </adm:treeContextMenu>

            <adm:jsonRpcCall method="StructureTreeWriter.renderStructureTree" args="-1, true, true"/>
    	</adm:tree>

        <div id="structureTreeContainer">
        </div>
    </ui:define>

    <ui:define name="mainMenu">
        <div class="menu">
            <fx:dojoMenu name="mainMenu">

                <fx:dojoMenuItem rendered="#{fxSystemBean.isInRole['StructureManagement']}" labelKey="StructureTree.menu.createType" icon="windowNew" clickHandler="function(menuItem) { createType(menuItem); }"/>
                <fx:dojoMenuItem rendered="#{fxSystemBean.isInRole['StructureManagement']}" labelKey="StructureTree.menu.createTypeRelation" icon="fxTypeRelation" clickHandler="function(menuItem) { createTypeRelation(menuItem); }"/>
                <fx:dojoMenuItem rendered="#{fxSystemBean.isInRole['StructureManagement']}" labelKey="StructureTree.menu.importType" icon="importContent" clickHandler="importType"/>
                <fx:dojoMenuItem rendered="#{fxSystemBean.isInRole['StructureManagement']}" labelKey="StructureTree.menu.exportType" icon="export" clickHandler="exportTypeMenu"/>

                <fx:dojoMenuSeparator/>

                <ui:include src="/adm/templates/navigation.menu.tabs.xhtml"/>
            </fx:dojoMenu>
        </div>
    </ui:define>

    <ui:define name="reloadButton">
        <a href="javascript:toggleHierarchyView()"><t:graphicImage id="imgTreeHierarchy" url="/adm/images/layout/tree_view_flat.png" alt="#{fxMessageBean['StructureTree.button.toggleHierarchyView']}" title="#{fxMessageBean['StructureTree.button.toggleHierarchyView']}" style="position:absolute;right:55px;margin-top:2px;border:0;"/></a>
        <a href="javascript:toggleAliasView()"><t:graphicImage id="imgTreeLabelView" url="/adm/images/layout/tree_label_label.png" alt="#{fxMessageBean['StructureTree.button.toggleAliasView']}" title="#{fxMessageBean['StructureTree.button.toggleAliasView']}" style="position:absolute;right:35px;margin-top:2px;border:0;"/></a>
        <a href="javascript:reloadStructureTree()"><t:graphicImage url="/adm/images/layout/reload.png" alt="#{fxMessageBean['StructureTree.button.reloadStructureTree']}" title="#{fxMessageBean['StructureTree.button.reloadStructureTree']}" style="position:absolute;right:15px;margin-top:2px;border:0;"/></a>
    </ui:define>

</ui:composition>


</html>
        

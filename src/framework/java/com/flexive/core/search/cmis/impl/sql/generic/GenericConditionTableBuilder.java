/***************************************************************
 *  This file is part of the [fleXive](R) framework.
 *
 *  Copyright (c) 1999-2008
 *  UCS - unique computing solutions gmbh (http://www.ucs.at)
 *  All rights reserved
 *
 *  The [fleXive](R) project is free software; you can redistribute
 *  it and/or modify it under the terms of the GNU Lesser General Public
 *  License version 2.1 or higher as published by the Free Software Foundation.
 *
 *  The GNU Lesser General Public License can be found at
 *  http://www.gnu.org/licenses/lgpl.html.
 *  A copy is found in the textfile LGPL.txt and important notices to the
 *  license from the author are found in LICENSE.txt distributed with
 *  these libraries.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  For further information about UCS - unique computing solutions gmbh,
 *  please see the company website: http://www.ucs.at
 *
 *  For further information about [fleXive](R), please see the
 *  project website: http://www.flexive.org
 *
 *
 *  This copyright notice MUST APPEAR in all copies of the file!
 ***************************************************************/
package com.flexive.core.search.cmis.impl.sql.generic;

import com.flexive.core.search.cmis.impl.sql.SelectedTableVisitor;
import com.flexive.core.search.cmis.impl.sql.SqlMapperFactory;
import com.flexive.core.search.cmis.model.*;

import java.util.Stack;

/**
 * A {@link com.flexive.core.search.cmis.model.ConditionNodeVisitor} to map the statement conditions to SQL.
 * <p>
 * The main task of this class is to accumulate the SQL generated by the individual conditions of the query,
 * and join them according to the {@link com.flexive.core.search.cmis.model.ConditionList.Connective}
 * type of the current subquery.
 * </p>
 * <p>
 * This generic implementation relies on a DBMS that implements both UNION and INTERSECT statement.
 * </p>
 * <ul>
 * <li>UNION is used to for disjunctive subconditions (OR)</li>
 * <li>INTERSECT is used for conjunctive subconditions (AND)</li>
 * </ul>
 * <p>
 * Due to the implementation of table joins in the CMIS-SQL mapper, this implementation
 * <strong>works only for queries without joins!</strong>
 * For queries with joins a variant of
 * {@link com.flexive.core.search.cmis.impl.sql.generic.GenericInnerJoinConditionTableBuilder}
 * (which uses inner joins instead of INTERSECT) should be used.
 * </p>
 * <p>
 * Also, some DBMS do not implement INTERSECT at all (most notably MySQL), in these cases 
 * {@link com.flexive.core.search.cmis.impl.sql.generic.GenericInnerJoinConditionTableBuilder}
 * should always be used.
 * </p>
 * <p>
 * To control instantiation of the visitor, override
 * {@link com.flexive.core.search.cmis.impl.sql.generic.GenericSqlDialect#createConditionNodeVisitor(StringBuilder, com.flexive.core.search.cmis.impl.sql.SelectedTableVisitor)}.
 * </p>
 *
 * @author Daniel Lichtenberger (daniel.lichtenberger@flexive.com), UCS - unique computing solutions gmbh (http://www.ucs.at)
 * @version $Rev$
 * @since 3.1
 */
public class GenericConditionTableBuilder implements ConditionNodeVisitor {
    protected final SqlMapperFactory factory;
    private final StringBuilder out;    // the final output
    private final Stack<StringBuilder> conditionWriters = new Stack<StringBuilder>();    // subcondition writers
    protected final SelectedTableVisitor joinedTables;
    protected Stack<ConditionList.Connective> typeStack = new Stack<ConditionList.Connective>();
    protected Stack<Integer> numStatements = new Stack<Integer>();
    protected int subconditionCounter;

    public GenericConditionTableBuilder(SqlMapperFactory factory, StringBuilder out, SelectedTableVisitor joinedTables) {
        this.factory = factory;
        this.out = out;
        this.joinedTables = joinedTables;
        numStatements.push(0);  // statement counter stack is never empty
    }

    /**
     * {@inheritDoc}
     */
    public void enterSubCondition(ConditionList.Connective type) {
        joinWithPreviousCondition();
        typeStack.push(type);
        numStatements.push(numStatements.pop() + 1);
        numStatements.push(0);
        conditionWriters.push(new StringBuilder());
        onEnterSubCondition(type);
    }

    /**
     * {@inheritDoc}
     */
    public void leaveSubCondition() {
        if (typeStack.empty()) {
            throw new IllegalStateException("More conditions left than entered.");
        }
        numStatements.pop();
        onLeaveSubCondition(typeStack.pop());
        // write result from subconditions
        if (conditionWriters.size() == 1) {
            // outmost condition left, flush output
            out.append(conditionWriters.pop());
        } else {
            // add output to enclosing condition
            final StringBuilder subResult = conditionWriters.pop();
            conditionWriters.peek().append(subResult);
        }
        onStatementAdded();     // for the outer condition, a new statement has been added
    }

    /**
     * {@inheritDoc}
     */
    @SuppressWarnings({"unchecked"})
    public void visit(ComparisonCondition comparison) {
        visitCondition(factory.getComparisonConditionSqlMapper().getConditionSql(factory, comparison, joinedTables));
    }

    /**
     * {@inheritDoc}
     */
    public void visit(ContainsCondition contains) {
        visitCondition(factory.getContainsConditionSqlMapper().getConditionSql(factory, contains, joinedTables));
    }

    /**
     * {@inheritDoc}
     */
    public void visit(LikeCondition like) {
        visitCondition(factory.getLikeConditionSqlMapper().getConditionSql(factory, like, joinedTables));
    }

    /**
     * {@inheritDoc}
     */
    public void visit(InCondition in) {
        visitCondition(factory.getInConditionSqlMapper().getConditionSql(factory, in, joinedTables));
    }

    /**
     * {@inheritDoc}
     */
    public void visit(NullCondition nullCondition) {
        visitCondition(factory.getNullConditionSqlMapper().getConditionSql(factory, nullCondition, joinedTables));
    }

    /**
     * Return the current output writer. Subconditions have their own writers.
     *
     * @return the current output writer
     */
    protected StringBuilder getOut() {
        return conditionWriters.isEmpty() ? out : conditionWriters.peek();
    }

    /**
     * Method called whenever a condition is visited.
     *
     * @param conditionSql the condition's SQL. It will be appended to the current output
     *                     writer obtained with {@link #getOut()}.
     */
    protected void visitCondition(String conditionSql) {
        checkMayAddCondition();
        joinWithPreviousCondition();
        getOut().append(conditionSql);
        numStatements.push(numStatements.pop() + 1);
        onStatementAdded();
    }

    /**
     * Add SQL code at the beginning of a subcondition (e.g. select from temporary table).
     *
     * @param type the sub condition's connective type (AND, OR)
     */
    protected void onEnterSubCondition(ConditionList.Connective type) {
        getOut().append("(SELECT * FROM (");
    }

    /**
     * Add SQL code at the end of a sub condition (e.g. close select, add subcondition alias).
     *
     * @param type the sub condition's connective type (AND, OR)
     */
    protected void onLeaveSubCondition(ConditionList.Connective type) {
        getOut().append(')').append("tbl").append(subconditionCounter++).append(')');
    }

    /**
     * Called when a statement has been added. If the database supports INTERSECT, no action is
     * required. However, one way to emulate INTERSECT is an inner join between the
     * results of the statements, thus we need to add a table alias after each statement. Look at
     * the {@link com.flexive.core.search.cmis.impl.sql.mysql.MySqlDialect} for an example.
     */
    protected void onStatementAdded() {
    }

    private void joinWithPreviousCondition() {
        if (numStatements.peek() > 0) {
            getOut().append(' ');
            if (ConditionList.Connective.AND.equals(typeStack.peek())) {
                getOut().append(joinConditionsAnd());
            } else {
                getOut().append(joinTablesOr());
            }
            getOut().append(' ');
        }
    }

    /**
     * Return the SQL code to be used for linking two conditions with "AND".
     *
     * @return the SQL code to be used for linking two conditions with "AND".
     */
    protected String joinConditionsAnd() {
        return "INTERSECT";
    }

    /**
     * Return the SQL code to be used for linking two conditions with "OR".
     *
     * @return the SQL code to be used for linking two conditions with "OR".
     */
    protected String joinTablesOr() {
        return "UNION";
    }

    private void checkMayAddCondition() {
        if (numStatements.peek() > 0 && typeStack.empty()) {
            throw new IllegalStateException("More than one condition, but no subcondition entered.");
        }
    }
}

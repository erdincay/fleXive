<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section [
        <!ENTITY % global_entities SYSTEM "../global.ent">
        %global_entities;
        ]>
<section xml:id="core_search" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude">

    <title>Search Engine</title>

    <xi:include href="../includes/author_dlichtenberger.xml"/>

    <para>
        &Flexive; contents can be queried using a SQL-like dialect called
        <glossterm>&fxsql;</glossterm>.
        The core idea of &fxsql; is to provide a flat virtual table that contains all content instances
        visible to the current user, with full support for &flexive; data types and multilingualism.
    </para>
    <para>
        While it is possible to submit queries in plain &fxsql;, there are alternatives
        for Java and Groovy developers in the form of query builders. They handle proper
        formatting of values and are the preferred way of formulating queries unless you need
        some of the more esoteric features of &fxsql;.
    </para>

    <section xml:id="core_search_sqlintro">
        <title>An introduction to &fxsql;</title>

        <para>
            The overall query layout is similar to SQL. Currently queries are always on
            the virtual table "content" that provides a flat view on all content instances.

            <xi:include href="../listings/core_search_intro.xml"/>

            <calloutlist>
                <callout arearefs="csq_intro_select">
                    <para>
                        We select the
                        <glossterm>virtual property</glossterm>
                        <code>@pk</code>
                        (the content primary key) and the standard property
                        <code>caption</code>.
                    </para>
                </callout>
                <!--
                                <callout arearefs="csq_intro_from">
                                    <para>
                                        Here we specify the (virtual) source table. Currently, this is always
                                        <code>content</code>. The alias is
                                        mandatory and is usually
                                        "<code>co</code>",
                                        although you can choose any identifier you like.
                                    </para>
                                </callout>
                -->
                <callout arearefs="csq_intro_filter">
                    <para>
                        Filters work similar to the SQL
                        <code>HAVING</code>
                        clause by providing a post-processing filter mechanism on
                        the results of the actual query. That is, filters are applied every time the search query is
                        executed, and are not stored in the cached result tables. This means that changing filters
                        usually does not invalidate the query cache, whereas changing the
                        <code>WHERE</code>
                        clause always does.
                        In this example, we might want to select only live versions. If you do not specify
                        a version filter, the search uses the maximum version of contents for matching
                        conditions and selecting properties.
                    </para>
                </callout>

                <callout arearefs="csq_intro_where">
                    <para>
                        The
                        <code>WHERE</code>
                        clause supports most standard SQL operators for string and numerical comparisons. Here
                        we select all contents whose caption starts with "test". Note that string comparisons are case
                        insensitive.
                    </para>
                </callout>

                <callout arearefs="csq_intro_order">
                    <para>
                        To control the sorting of the result set, you can specify one or more columns in the
                        <code>ORDER BY</code>
                        clause. By default an ascending sort is used, to sort by descending values add
                        <code>DESC</code>
                        to the column alias (e.g.
                        <code>ORDER BY id DESC</code>). Note that you can only use columns that
                        are specified in the
                        <code>SELECT</code>
                        clause.
                    </para>
                </callout>
            </calloutlist>

            The rest of this section contains an enumeration of &fxsql; features along with
            example queries demonstrating that feature.
        </para>

        <section xml:id="css_feature_userdefined">
            <title>Select user-defined columns</title>
            <para>
                When search results are displayed to the user, it is often desirable to let the user choose the
                displayed columns. For this purpose, the
                <interfacename>ResultPreferencesEngine</interfacename>
                provides a simple API for retrieving
                and setting the preferred column layout based on the result type (e.g. Articles or Images). To
                select these user-defined column layouts, add the
                <code>@*</code>
                virtual property:
                <programlisting language="sql"><![CDATA[SELECT caption, @*]]></programlisting>
                This is the only virtual property that actually expands to multiple columns, so it should
                appear at the end of the select clause.
            </para>
        </section>

        <section xml:id="css_feature_wildcard">
            <title>Select all columns</title>
            <para>
                To select all available columns, use the wildcard selector
                <code>*</code>.
                The wildcard expands to all properties of the content type returned to the user.
                When the result rows contain objects of more than one type, only the properties assigned
                to the root type are selected (i.e. properties that are defined for all types).
                This example selects all properties of the article type, since only articles
                (with a caption) will be returned:
                <programlisting language="sql"><![CDATA[SELECT *
WHERE #article/title IS NOT NULL]]></programlisting>
            </para>
        </section>

        <section xml:id="css_feature_fulltext">
            <title>Fulltext search</title>

            <para>
                A main feature of the &flexive; search engine is full-text indexing. By specifying the "*" property in
                the where clause, you will search across all indexed properties of a content.
                <programlisting language="sql"><![CDATA[SELECT @pk, caption
WHERE * = 'test']]></programlisting>
                Note that the only supported operator for full-text queries is "=" (equals) and that properties have to
                be enabled for fulltext indexing (See
                <xref linkend="core_structures_property_parameters"/>).
            </para>

            <para>
                The exact semantics of the fulltext query depend on the underlying database storage:

                <itemizedlist>
                    <listitem>
                        <para>
                            MySQL supports wildcards and boolean search expressions as described in
                            <link xlink:href="http://dev.mysql.com/doc/refman/5.1/en/fulltext-boolean.html">the MySQL reference manual</link>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            PostgreSQL and H2 currently do not support wildcards.
                        </para>
                </listitem>
            </itemizedlist>
            </para>
        </section>

        <section xml:id="css_feature_assignments">
            <title>Properties versus assignments</title>
            <para>
                When specifying a search property by name, you search across all properties of the given name. If you
                want to search in specific assignments, i.e. only in the address assignment of your contact data type,
                you have to either specify the assignment ID (prefixed by a # character) or the &xpath; prefixed by the
                type and without cardinalities instead of the property name.
            </para>

            <para>
                Select the
                <emphasis>property</emphasis>
                <code>caption</code>
                and search in the assignment with ID=25 for main street:
                <programlisting language="sql"><![CDATA[SELECT @pk, caption
WHERE #25 like 'main street']]></programlisting>
            </para>

            <para>
                Select the
                <emphasis>assignment</emphasis>
                <code>ARTICLE/TEASER/TEASER_TITLE</code>
                where the assignment
                <code>ARTICLE/TITLE</code>
                starts with Earthquake:

                <programlisting language="sql"><![CDATA[SELECT @pk, #ARTICLE/TEASER/TEASER_TITLE
WHERE #ARTICLE/TITLE LIKE 'Earthquake%']]></programlisting>
            </para>
        </section>

        <section xml:id="css_permissions">
            <title>Content permissions</title>
            <para>
                The
                <glossterm>virtual property</glossterm>
                <code>@permissions</code>
                selects the permissions of the calling user on the content instance:

                <programlisting language="sql"><![CDATA[SELECT @pk, @permissions]]></programlisting>

                The column returns instances of
                <link xlink:href="&flexiveJavadocBase;shared/com/flexive/shared/security/PermissionSet.html">
                    <classname>com.flexive.shared.security.PermissionSet</classname>.
                </link>
            </para>
        </section>

        <section xml:id="css_metadata">
            <title>Metadata</title>
            <para>
                When performing a search on a content collection that supports metadata such as
                <link linkend="core_briefcases">briefcases</link>,
                you can select the metadata of an item using the
                <glossterm>virtual property</glossterm>
                <code>@metadata</code>.

                <programlisting language="sql"><![CDATA[SELECT @pk, @metadata FILTER briefcase=21]]></programlisting>

                The
                <code>@metadata</code>
                column returns instances of type
                <link xlink:href="&flexiveJavadocBase;shared/com/flexive/shared/FxReferenceMetaData.html">
                    <classname>com.flexive.shared.FxReferenceMetaData&lt;FxPK></classname>.
                </link>
            </para>
        </section>

        <section xml:id="css_lock">
            <title>Lock information</title>
            <para>
                To obtain the
                <link xlink:href="&flexiveJavadocBase;shared/com/flexive/shared/FxLock.html">
                    <classname>FxLock</classname>
                </link>
                instance associated to a content, selected the
                <glossterm>virtual property</glossterm>
                <code>@lock</code>.


                <programlisting language="sql"><![CDATA[SELECT @pk, @lock]]></programlisting>

                When the content instance is not locked, the
                <code>@lock</code>
                column returns
                <code>null.</code>
            </para>
        </section>

        <section xml:id="css_tree">
            <title>Tree Search</title>

            <para>
                &Flexive; also supports searching inside the &contentTree; and returns tree paths of contents
                linked in the tree.
            </para>

            <section xml:id="csst_children">
                <title>Select all children of a node</title>
                <para>
                    To select all contents attached to a node or its children, use the
                    <code>IS CHILD OF</code>
                    condition and specify
                    the tree node ID (the root node is always 1).

                    <programlisting language="sql"><![CDATA[SELECT @pk
WHERE IS CHILD OF 1]]></programlisting>
                </para>
            </section>

            <section xml:id="csst_directchildren">
                <title>Select all direct children of a node</title>
                <para>
                    To include only contents attached directly to a given tree node, use
                    <code>IS DIRECT CHILD OF</code>.

                    <programlisting language="sql"><![CDATA[SELECT @pk
WHERE IS DIRECT CHILD OF 1]]></programlisting>
                </para>
            </section>

            <section xml:id="csst_treepaths">
                <title>Select the tree paths of a content instance</title>
                <para>
                    To select all tree paths of a content in the tree, use the
                    <glossterm>virtual property</glossterm>
                    <code>@path</code>. The column then
                    returns a
                    <interfacename>FxPaths</interfacename>
                    object that contains all tree paths
                    including their content captions. The standard search result table renders these objects as
                    <glossterm>breadcrumbs</glossterm>.

                    <programlisting language="sql"><![CDATA[SELECT @path]]></programlisting>

                    Note that this also returns contents not linked in the tree, so you may want to limit your search to
                    children of the root node:

                    <programlisting language="sql"><![CDATA[SELECT @path WHERE IS CHILD OF 1]]></programlisting>
                </para>
            </section>

            <section xml:id="csst_nodeposition">
                <title>Using the tree sort order</title>
                <para>
                    Tree nodes have a position field that explicitly specifies the ordering of
                    nodes in a folder. You can access the node position in the
                    <code>SELECT</code>
                    and
                    <code>ORDER BY</code>
                    clauses using the
                    <glossterm>virtual property</glossterm>
                    <code>@node_position</code>.

                    <programlisting language="sql"><![CDATA[SELECT @pk, @node_position, caption
WHERE IS DIRECT CHILD OF 1     -- select all nodes of the root folder
ORDER BY @node_position DESC   -- invert tree sort order]]></programlisting>
                </para>
            </section>
        </section>

        <section xml:id="css_datetime">
            <title>Date and Time Functions</title>

            <para>
                &fxsql; supports date and time functions similar to MySQL for
                <code>FxDate</code>
                and
                <code>FxDateTime</code>
                properties. They can be used to select or query against a partial date value.
                For example, this query selects all contents created in March 2008:
                <programlisting language="sql"><![CDATA[SELECT created_at
WHERE YEAR(created_at) = 2008
  AND MONTH(created_at) = 3]]></programlisting>
            </para>
            <para>
                Date and time functions may be used both in the
                <code>SELECT</code>
                and
                <code>WHERE</code>
                clauses. When a function is used in a column select, it may also be used
                for sorting if you specify the column index instead of the name, for example:
                <programlisting language="sql"><![CDATA[SELECT created_at, SECOND(created_at)
ORDER BY 2]]></programlisting>
            </para>
            <table xml:id="css_datetime_functions" class="flexive">
                <caption>Date and Time functions provided in &fxsql;</caption>
                <thead>
                    <tr>
                        <th>Function</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>YEAR()</td>
                        <td>Selects the year of a date.</td>
                    </tr>
                    <tr>
                        <td>MONTH()</td>
                        <td>Selects the month of a date, month 1 is january.</td>
                    </tr>
                    <tr>
                        <td>DAY()</td>
                        <td>Selects the day of the month of a date.</td>
                    </tr>
                    <tr>
                        <td>HOUR()</td>
                        <td>Selects the hour. This part is only defined for
                            <code>FxDateTime</code>
                            objects.
                        </td>
                    </tr>
                    <tr>
                        <td>MINUTE()</td>
                        <td>Selects the minute. This part is only defined for
                            <code>FxDateTime</code>
                            objects.
                        </td>
                    </tr>
                    <tr>
                        <td>SECOND()</td>
                        <td>Selects the second. This part is only defined for
                            <code>FxDateTime</code>
                            objects.
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section xml:id="css_type_conditions">
            <title>Type conditions</title>

            <para>
                To explicitly limit the types returned by a query, you can use explicit type conditions.
                &fxsql; also supports sub- and supertype queries.
            </para>

            <table xml:id="css_type_condition_table" class="flexive">
                <caption>Type conditions in FxSQL</caption>
                <thead>
                    <tr>
                        <th>Condition</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>typedef = 'IMAGE'</td>
                        <td>Returns only instances of the Image type.</td>
                    </tr>
                    <tr>
                        <td>typedef >= 'IMAGE'</td>
                        <td>Returns instances of the Image type or any type derived from image (inclusive subtype match).</td>
                    </tr>
                    <tr>
                        <td>typedef > 'IMAGE'</td>
                        <td>Returns instances of any type derived from Image, but not Image itself (exclusive subtype match).</td>
                    </tr>
                    <tr>
                        <td>typedef &lt; 'DERIVED_TYPE'</td>
                        <td>Returns instances of any supertype (parent type) of Derived_Type (exclusive supertype match).</td>
                    </tr>
                    <tr>
                        <td>typedef &lt;= 'DERIVED_TYPE'</td>
                        <td>Returns instances of Derived_Type or any of its parent types (inclusive supertype match).</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section xml:id="css_selectone">
            <title>Select list properties</title>
            <para>
                Selecting properties with data type
                <code>SelectOne</code>
                returns the complete select item. You can also query individual columns as they
                are stored in the table
                <code>FXS_SELECTLIST_ITEM</code>,
                which is useful for custom sorts (otherwise the result can only be ordered by the system-internal item ID).
                Useful column names include
                <code>ID, NAME, DATA, COLOR, POS</code>
                (for example:
                <code>SELECTPROP.POS</code>
                to select the item position).
            </para>
        </section>

        <section xml:id="css_selectors">
            <title>Resolving system properties</title>
            <para>
                Of course you can select all system properties, like
                <code>acl</code>
                or
                <code>created_by</code>,
                in your query. Some system properties are linked to their backing table.
                For example, the
                <code>acl</code>
                property is linked to the
                <code>FXS_ACL</code>
                table, so you can select any column in that table using a field suffix:
                <code>acl.description</code>
                selects the description column, and
                <code>acl.color</code>
                returns the color code. The most useful field, however, is the virtual
                <code>acl.label</code>
                field that returns the ACL label in the calling user's language.
            </para>
            <para>
                Another useful example is to select the user name that created a content, instead
                of the account ID:

                <programlisting language="sql"><![CDATA[SELECT @pk, created_by.username]]></programlisting>
            </para>
            <para>
                The following table contains all system properties that are linked to their backing table,
                including the most important fields. For a complete field list, please refer to
                the database schema.
            </para>
            <table xml:id="css_selectors_tables" class="flexive">
                <caption>System property fields provided in &fxsql;</caption>
                <thead>
                    <tr>
                        <th>Property (Table)</th>
                        <th>Fields</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>acl (FXS_ACL)</td>
                        <td>
                            Selects the content ACL. Additional fields include:
                            <variablelist>
                                <varlistentry>
                                    <term>
                                        <code>acl.label</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The localized label in the calling user's language.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>acl.name</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The unique name of the ACL.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>acl.description</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The ACL description.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>acl.cat_type</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The ACL category.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>acl.color</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The RGB color code used for this ACL.
                                        </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        </td>
                    </tr>

                    <tr>
                        <td>created_by, modified_by (FXS_ACCOUNTS)</td>
                        <td>
                            Selects the user that has created/lastly modified the content
                            (
                            <code>created_by</code>
                            and
                            <code>modified_by</code>
                            both have the same fields). Interesting fields include:
                            <variablelist>
                                <varlistentry>
                                    <term>
                                        <code>created_by.username</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The associated user's username.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>created_by.email</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The associated user's email address.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>created_by.login_name</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The unique login name of the user.
                                        </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        </td>
                    </tr>

                    <tr>
                        <td>mandator (FXS_MANDATOR)</td>
                        <td>
                            Selects the mandator of the content instance. To select the mandator name, use
                            <code>mandator.name</code>.
                        </td>
                    </tr>

                    <tr>
                        <td>step (FXS_WF_STEPS)</td>
                        <td>
                            Selects the workflow step of the content instance. You can select the following fields:
                            <variablelist>
                                <varlistentry>
                                    <term>
                                        <code>step.label</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The localized step label in the calling user's language.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>step.workflow</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The workflow ID of the step (and thus the complete workflow used for this
                                            content
                                            instance).
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>step.stepdef</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The step definition ID.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>step.acl</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The ACL of the step.
                                        </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        </td>
                    </tr>

                    <tr>
                        <td>typedef (FXS_TYPEDEF)</td>
                        <td>
                            Selects the type ID of the content instance.
                            <variablelist>
                                <varlistentry>
                                    <term>
                                        <code>typedef.name</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The unique type name.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>typedef.description</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The type description in the language selected for the query. 
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>typedef.acl</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The type ACL.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>typedef.parent</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            The parent type ID.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>typedef.workflow</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            Returns 1 if workflows are enabled for this type.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <code>typedef.trackhistory</code>
                                    </term>
                                    <listitem>
                                        <para>
                                            Returns 1 if history tracking is enabled for this type.
                                        </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        </td>
                    </tr>

                </tbody>
            </table>
        </section>

        <section xml:id="css_filters">
            <title>Filters</title>
            <para>
                Filters work similar to the SQL having clause by providing a post-processing filter mechanism on the
                results of the actual query. That is, filters are applied every time the search query is executed, and
                are not stored in the cached result tables. This means that changing filters usually does not invalidate
                the query cache, whereas changing the WHERE clause always does.
            </para>
            <para>
                Filters applicable to the &flexive; content table:
                <variablelist>
                    <varlistentry>
                        <term>
                            <code>TYPE=type</code>
                        </term>
                        <listitem>
                            <para>
                                Return only contents of the given type. You may specify either the type name (e.g.
                                "ARTICLE") or the type ID (e.g. "2").
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>
                            <code>VERSION=AUTO|MAX|LIVE|ALL</code>
                        </term>
                        <listitem>
                            <para>
                                Restricts the Version, AUTO defaults to MAX. If version=live is selected and an
                                object has no live version, it is omitted.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>
                            <code>SEARCH_LANGUAGES=iso2Code[|iso2Code]*</code>
                        </term>
                        <listitem>
                            <para>
                                Restrict search to languages contained in the list of language ISO codes
                                separated by "|" (e.g. SEARCH_LANGUAGES=en|de).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                General filters:
                <variablelist>
                    <varlistentry>
                        <term>
                            <code>BRIEFCASE=briefcaseId[,briefcaseId]?</code>
                        </term>
                        <listitem>
                            <para>
                                Perform search in one or more briefcases. When exactly one briefcase is specified,
                                the metadata associated with the items can be selected with the column
                                <code>@metadata</code>.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>
                            <code>IGNORE_CASE=[true|false]</code>
                        </term>
                        <listitem>
                            <para>
                                Query case sensitive?
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>
                            <code>MAX_RESULTROWS=number</code>
                        </term>
                        <listitem>
                            <para>
                                Limit number of rows returned.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </section>

        <section xml:id="css_orderby">
            <title>Order by</title>

            <para>
                To control the sort order of the result set, you can specify one or more
                columns in the
                <code>ORDER BY clause</code>.
                Usually you specify the name of a column previously selected in the
                <code>SELECT</code>
                clause, but you can also use the 1-based column index. The direction of the sort
                (ascending or descending) is set using the
                <code>ASC</code>
                and
                <code>DESC</code>
                modifiers, respectively.
                The following two queries order the
                result by the properties
                <code>priority</code>
                and
                <code>caption</code>
                (i.e. first the result is sorted by priority, then by caption), the first
                uses named columns, the second specifies the column indices instead:

                <programlisting language="sql"><![CDATA[SELECT @pk, caption, priority
ORDER BY priority DESC, caption]]></programlisting>

                <programlisting language="sql"><![CDATA[SELECT @pk, caption, priority
ORDER BY 3 DESC, 2]]></programlisting>
            </para>

            <section xml:id="css_orderby_userdefined">
                <title>Order by user-defined columns</title>

                <para>
                    As described in
                    <xref linkend="css_feature_userdefined"/>,
                    <code>@*</code>
                    expands to whatever columns the user defined for the result content type.
                    This causes a problem when the result should be sorted manually by one of these columns,
                    e.g. because the result table has sortable column headers
                    (as in the result table in the &backendGui;): the &fxsql; parser has no way
                    to expand
                    <code>@*</code>
                    (because the search has not been submitted yet and thus the content type is unknown),
                    but yet it must be possible to sort by one of these columns.
                    For example, this query does not work:
                </para>
                <programlisting language="sql"><![CDATA[SELECT @*
ORDER BY caption DESC     -- caption not found in SELECT clause]]></programlisting>
                <para>
                    As a workaround, it is possible to specify otherwise invalid column indices in the
                    <code>ORDER BY</code>
                    clause
                    <emphasis>if</emphasis>
                    <code>@*</code>
                    was selected. Of course this may lead to runtime errors if the user-defined columns
                    are less than the ORDER BY index. In the most probable use case, on-the-fly
                    sorting of a result table, this is not a problem, since the user
                    can only sort by columns that have already been rendered.
                </para>
                <para>
                    For example, the following is a valid &fxsql; query but relies on the user
                    having defined at least 3 columns for the result type:
                </para>
                <programlisting language="sql"><![CDATA[SELECT @*
ORDER BY 3 DESC     -- order by the third column of @*]]></programlisting>
            </section>
        </section>

        <section xml:id="css_comments">
            <title>Comments</title>

            <para>
                For testing and documentation purposes you can embed comments in your query. For a standard
                line-based SQL comment use
                "<code>--</code>",
                for an inline or multiline comment use C-style comments in the form of
                "<code>/*...*/</code>"

                <programlisting language="sql"><![CDATA[SELECT /* inline comment */ id
WHERE id > 0    -- conditions]]></programlisting>
            </para>
        </section>

        <section xml:id="css_operators">
            <title>Operator table</title>
            <para>
                The following operators are supported by &fxsql;. Note that not all data types
                support all operators.
            </para>

            <table xml:id="csso_table" class="flexive">
                <caption>&fxsql; operator table</caption>
                <thead>
                    <tr>
                        <th>Operator</th>
                        <th>Short name</th>
                        <th>Description</th>
                        <th>&Flexive; Datatypes
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>=</td>
                        <td>equals</td>
                        <td>Checks for equality</td>
                        <td>All except FxBinary</td>
                    </tr>
                    <tr>
                        <td>!=</td>
                        <td>not equals</td>
                        <td>Checks for inequality</td>
                        <td>All except FxBinary</td>
                    </tr>
                    <tr>
                        <td>&lt;=</td>
                        <td>
                            less than
                        </td>
                        <td>Compares a property or assignment to a given constant value</td>
                        <td>All numerical and time types</td>
                    </tr>
                    <tr>
                        <td>&gt;</td>
                        <td>
                            greater than
                        </td>
                        <td>Compares a property or assignment to a given constant value</td>
                        <td>All numerical and time types</td>
                    </tr>
                    <tr>
                        <td>&lt;=</td>
                        <td>
                            less or equal
                        </td>
                        <td>Compares a property or assignment to a given constant value</td>
                        <td>All numerical and time types</td>
                    </tr>
                    <tr>
                        <td>&gt;=</td>
                        <td>
                            greater or equal
                        </td>
                        <td>Compares a property or assignment to a given constant value</td>
                        <td>All numerical and time types</td>
                    </tr>
                    <tr>
                        <td>LIKE</td>
                        <td>
                            string match with wildcards
                        </td>
                        <td>
                            Like string equality, but allows the use of the
                            <code>%</code>
                            wildcard which matches any string, including the empty string. For example,
                            <code>"LIKE 'Test%'"</code>
                            matches all string values that
                            begin with "Test".
                        </td>
                        <td>
                            FxString
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section xml:id="css_literals">
            <title>Literal value formatting</title>

            <para>
                Currently all conditions in &fxsql; queries involve at least one literal value, e.g.
                <code>WHERE title = 'test'</code>. The following table lists all supported literal
                value formats and the &flexive; types they may be applied to.
            </para>

            <table xml:id="cssl_table" class="flexive">
                <caption>&fxsql; literal value formats</caption>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Example</th>
                        <th>Description</th>
                        <th>&Flexive; Datatypes
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>String</td>
                        <td>'string value'</td>
                        <td>A simple string value. Single quotes are escaped like in SQL using double quotes,
                            e.g. 'te''st' is the representation of the string value
                            <code>te'st</code>.
                        </td>
                        <td>
                            FxString, FxHTML
                        </td>
                    </tr>

                    <tr>
                        <td>Integer</td>
                        <td>21</td>
                        <td>Any integer number. The valid range depends on the property datatype, e.g.
                            FxNumber (int) or FxLargeNumber (long).
                        </td>
                        <td>
                            FxNumber, FxLargeNumber, FxSelectOne, FxSelectMany,
                            internal referential datatypes (e.g. ACL, mandator)
                        </td>
                    </tr>

                    <tr>
                        <td>Date</td>
                        <td>'2008-03-18'</td>
                        <td>A date value. Note that in current &fxsql; you cannot use a date literal
                            to compare against a DateTime value - you need to write a manual range
                            condition for the given day instead, e.g.:
                            <code>created_at > '2008-03-10 00:00:00.000' AND created_at &lt; '2008-03-11
                                00:00:00.000'
                            </code>
                            to find contents created on 2008/03/10.
                        </td>
                        <td>
                            FxDate, FxDateRange
                        </td>
                    </tr>

                    <tr>
                        <td>DateTime</td>
                        <td>'2008-03-18 15:23:05.159'</td>
                        <td>
                            A precise time value with millisecond resolution. Note that millisecond resolution
                            is currently only supported for the system properties
                            <code>CREATED_AT</code>
                            and
                            <code>MODIFIED_AT</code>. For other properties the millisecond part is always 0.
                        </td>
                        <td>
                            FxDateTime, FxDateTimeRange
                        </td>
                    </tr>

                    <tr>
                        <td>Boolean</td>
                        <td>true</td>
                        <td>
                            A boolean value (true or false).
                        </td>
                        <td>
                            FxBoolean
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>

    <section xml:id="core_search_java">
        <title>SqlQueryBuilder: Building queries in Java</title>

        <para>
            To ease the pain of having to learn yet another query language, the
            <classname>SqlQueryBuilder</classname>
            provides a thin builder interface for &fxsql; queries. The query is created
            using chained calls to the builder and results in a &fxsql; query.
            For example:
            <xi:include href="../listings/core_search_querybuilder.xml"/>
            <calloutlist>
                <callout arearefs="csq_builder_1">
                    <para>
                        A new query builder is created.
                    </para>
                </callout>
                <callout arearefs="csq_builder_2">
                    <para>
                        We select three columns, the
                        <glossterm>virtual property</glossterm>
                        <code>@pk</code>, the content creation date,
                        and the article caption.
                    </para>
                </callout>
                <callout arearefs="csq_builder_3">
                    <para>
                        We want to search only for contents of type
                        <code>Article</code>.
                    </para>
                </callout>
                <callout arearefs="csq_builder_4">
                    <para>
                        Order the result by creation date, return newest articles first
                        (<constant>SortDirection.DESCENDING</constant>). You can issue multiple calls to
                        <methodname>orderBy</methodname>
                        for sorting by multiple columns. You can also specify the column index
                        instead of the column name. If you specify the property name, you must ensure that
                        this property is selected, otherwise the query builder throws a
                        <exceptionname>FxRuntimeException</exceptionname>.
                    </para>
                </callout>
                <callout arearefs="csq_builder_5">
                    <para>
                        The
                        <methodname>getResult()</methodname>
                        call submits the search query to the search engine EJB and returns a
                        <interfacename>FxResultSet</interfacename>.
                    </para>
                </callout>
            </calloutlist>
            A call to
            <methodname>SqlQueryBuilder#getQuery()</methodname>
            returns the actual &fxsql; query, for example, the code snippet above built this &fxsql; query:
            <programlisting language="sql"><![CDATA[SELECT @pk, created_at, caption
WHERE (typedef = 'article')
ORDER BY created_at DESC]]></programlisting>
        </para>

        <section xml:id="csj_conditions">
            <title>Conditions</title>

            <para>
                The basic query condition specifies
                <orderedlist>
                    <listitem>
                        <para>
                            a property or assignment whose value will be compared,
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            a
                            <classname>PropertyValueComparator</classname>
                            specifying the compare
                            operator (like equals or greater), and
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            a constant value to compare the content value against, like "5" or "Test".
                            Comparisons between content values are not supported.
                        </para>
                    </listitem>
                </orderedlist>

                <classname>SqlQueryBuilder</classname>
                offers an overloaded, general-purpose
                <methodname>condition()</methodname>
                method for specifying arbitrary conditions,
                and custom condition methods for tree queries and content type constraints:

                <variablelist>
                    <varlistentry>
                        <term>
                            <methodname>condition(...)</methodname>
                        </term>
                        <listitem>
                            <para>
                                Add a condition to the query. This method is overloaded to support both
                                assignment and property queries, for the actual method signatures please refer
                                to the &flexiveJavadoc;. If you want to apply a function (e.g.
                                <code>YEAR(prop)</code>),
                                you have to use the generic
                                <code>condition(String, ...)</code>
                                methods.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>
                            <methodname>isChild(nodeId)</methodname>
                        </term>
                        <listitem>
                            <para>
                                Adds a tree search condition to the query that limits the search to
                                children (direct and indirect) of the given tree node ID. See
                                <xref linkend="css_tree"/>.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>
                            <methodname>isDirectChild(nodeId)</methodname>
                        </term>
                        <listitem>
                            <para>
                                Like
                                <methodname>isChild</methodname>, but includes only direct
                                children of the given node.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>
                            <methodname>type(contentType)</methodname>
                        </term>
                        <listitem>
                            <para>
                                Adds a content type constraint to the query, i.e. the expression
                                will match only contents of the given type. Note that this is semantically
                                different from a content type filter, which will be covered in the next section.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </section>

        <section xml:id="csj_filters">
            <title>Filters</title>

            <para>
                Query filters provide filtering capabilities on top of the search result. Currently
                only the type and briefcase filters are supported.

                <variablelist>
                    <varlistentry>
                        <term>
                            <methodname>filterType(contentType)</methodname>
                        </term>
                        <listitem>
                            <para>
                                Applies a content type filter on the result. The query conditions are
                                not modified by this statement, so it can be called after the query building
                                has been finished, which is not the case for the
                                <methodname>type()</methodname>
                                condition.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term>
                            <methodname>filterBriefcase(briefcaseId)</methodname>
                        </term>
                        <listitem>
                            <para>
                                Searches only inside the contents of the given briefcase. When no
                                query conditions are specified, the briefcase contents are returned.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </section>

        <section xml:id="csj_nested">
            <title>Nested conditions</title>

            <para>
                The
                <interfacename>SqlQueryBuilder</interfacename>
                provides support for building nested conditions like
                <code>caption LIKE 'Test%' AND (created_by = 21 OR created_by = 22)</code>.
            </para>

            <variablelist>
                <varlistentry>
                    <term><methodname>andSub()</methodname>,
                        <methodname>orSub()</methodname>
                    </term>
                    <listitem>
                        <para>
                            Creates a new sub-query whose conditions will be joined with the
                            <code>AND</code>
                            or
                            <code>OR</code>
                            operator respectively. After creating a sub-query, you can
                            issue condition builder calls exactly like in the top level.
                            The top-level query is opened implicitly and uses the
                            <code>AND</code>
                            operator.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                        <methodname>closeSub()</methodname>
                    </term>
                    <listitem>
                        <para>
                            Closes a sub-query. The implicitly opened top-level query does not have
                            to be closed.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <example xml:id="csj_nested_ex">
                <title>Creating a nested query</title>
                <programlisting language="java"><![CDATA[new SqlQueryBuilder()
    .select("@pk")
    .type("article")
    .orSub()
        .condition("caption", PropertyValueComparator.EQ, "Test caption")
        .condition("caption", PropertyValueComparator.EQ, "Another test caption")
    .closeSub()
    .getQuery();]]></programlisting>

                Result:
                <programlisting language="sql"><![CDATA[SELECT @pk
WHERE (typedef = 'article' AND (caption = 'Test caption' OR caption = 'Another test caption'))]]>
                </programlisting>
            </example>
        </section>

        <section xml:id="csj_params">
            <title>Search parameters</title>

            <para>
                When submitting a query directly with the
                <classname>SqlQueryBuilder</classname>,
                miscellaneous search parameters can be set. Note that these parameters are not
                part of the &fxsql; query, so if you submit the search by yourself, you cannot use
                these methods.
            </para>

            <variablelist>
                <varlistentry>
                    <term>
                        <methodname>setMaxRows(int)</methodname>
                    </term>
                    <listitem>
                        <para>
                            Sets the maximum number of rows returned by the search query.
                            Useful mostly for paged result tables.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                        <methodname>setStartRow(int)</methodname>
                    </term>
                    <listitem>
                        <para>
                            Sets the first row of the search result that should be included in the
                            result set. The first row has index 0.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                        <methodname>setViewType(ResultViewType)</methodname>
                    </term>
                    <listitem>
                        <para>
                            Sets the view type (list or thumbnails) when displaying the results to the
                            user. This is only relevant when you select the
                            <code>@*</code>
                            property, which will select the user's predefined result columns
                            and sort settings based on this view type. The view type as well as the
                            location can also be specified in the constructor.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

        </section>
    </section>

    <section xml:id="core_search_groovy">
        <title>The Groovy query builder</title>
        <para>
            For Groovy developers, the
            <classname>GroovyQueryBuilder</classname>
            offers an even more convenient way of formulating &fxsql; queries. Note that this class
            (like the rest of Groovy support classes) is still experimental, so not all features may
            work as intended.
        </para>
        <para>
            Currently the Groovy builder supports defining the column selection, nested
            property conditions and briefcase filtering. The query builder actually builds
            a query tree similar to the JSF search query editor, so the result object is of type
            <classname>QueryRootNode</classname>. From this class you can get either the final
            &fxsql; query from the
            <property>sqlQuery</property>
            property, or the
            <interfacename>SqlQueryBuilder</interfacename>
            which has been used for building the query from the
            <property>queryBuilder</property>
            property.
        </para>
        <example xml:id="csg_ex">
            <title>Specifying a query with the
                <classname>GroovyQueryBuilder</classname>
            </title>
            <programlisting language="groovy"><![CDATA[new GroovyQueryBuilder().select(["@pk", "caption", "@*"]) {
    filterBriefcase(21)
    eq("caption", "test")
    not_empty("filename")
    or {
        gt("id", 0)
        lt("id", 100)
    }
    lt("created_at", new Date())
}.sqlQuery
]]></programlisting>
            Result:
            <programlisting language="sql"><![CDATA[SELECT @pk, caption, @*
FILTER briefcase=21
WHERE (CAPTION = 'test' AND FILENAME IS NOT NULL AND
       (ID > 0 OR ID < 100)
       AND CREATED_AT < '2008-04-04 11:17:27.886')
]]></programlisting>
            <para>
                The method names (except
                <code>select</code>
                and
                <code>filterBriefcase</code>
                )
                are the enumeration values of
                <classname>PropertyValueComparator</classname>, so any comparison supported by the
                <classname>SqlQueryBuilder</classname>
                is also supported by the Groovy builder.
            </para>
        </example>
    </section>

    <section xml:id="core_search_results">
        <title>Working with search results</title>

        <para>
            When a &fxsql; query is submitted to the database, all rows are fetched at once and
            returned in a
            <interfacename>FxResultSet</interfacename>
            object. It contains all result rows within the user-defined limits
            (unlike the cursor-approach of JDBC), including miscellaneous
            information like the selected column names, or row count information.
        </para>

        <section xml:id="csr_rows">
            <title>Accessing result rows</title>

            <para>
                There are two ways of accessing the result rows:
                <orderedlist>
                    <listitem>
                        <para>
                            The
                            <methodname>FxResultSet#getResultRows()</methodname>
                            method returns an iterable object that returns
                            <classname>FxResultRow</classname>
                            objects
                            for each row in the resultset. Take a look at the example demonstrating accessing
                            the row columns both by index and column name.

                            <example xml:id="csrr_ex">
                                <title>Iterating over a
                                    <interfacename>FxResultSet</interfacename>
                                </title>
                                <programlisting language="java"><![CDATA[FxResultSet result = new SqlQueryBuilder().select("@pk", "caption")
        .condition("caption", PropertyValueComparator.LIKE, "test caption%")
        .getResult();
for (FxResultRow row: result.getResultRows()) {
    assert row.getPk(1).equals(row.getPk("@pk"));
    assert row.getFxValue(2).equals(row.getFxValue("caption"));
}
]]></programlisting>
                            </example>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            The result row table can be accessed with
                            <methodname>FxResultSet#getRows()</methodname>, which returns a
                            <type>List&lt;Object[]&gt;</type>. This is best when you need indexed
                            access in constant time and need only the raw result values (usually
                            <classname>FxValue</classname>
                            objects).
                            The following code iterates over all rows of a result set:
                            <example xml:id="csrr_direct_ex">
                                <title>
                                    Directly accessing the search results using
                                    <methodname>getRows()</methodname>
                                </title>
                                <programlisting language="java"><![CDATA[for (int i = 0; i < result.getRowCount(); i++) {
    for (int j = 0; j < result.getColumnCount(); j++) {
        System.out.print(result.getRows().get(i)[j] + ' ');
    }
    System.out.println();
}]]></programlisting>
                            </example>
                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>


        <section xml:id="csr_projections">
            <title>Projections</title>

            <para>
                Sometimes you do not want to work with the full result table, but only need
                a list of property values, for example primary keys. The
                <methodname>FxResultSet#collectColumn(int)</methodname>
                method projects a single column of the result set to a linear list.
                For example, to collect all primary keys of a &flexive; type you submit
                a query against that type, selecting only the
                <code>@pk</code>
                column, and then project the first result column using
                <methodname>collectColumn</methodname>:

                <programlisting language="java"><![CDATA[final List<FxPK> folderPks =
    new SqlQueryBuilder().select("@pk").type("FOLDER").getResult().]]><emphasis>collectColumn(1)</emphasis>;
                </programlisting>
            </para>
        </section>

    </section>
</section>
